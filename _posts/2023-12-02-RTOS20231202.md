---
layout: post
title: 'XiLinx SDK FreeRTOS学习记录（二）——UART与蓝牙收发'
---
## 前置知识
这篇文章结合了上一篇文章[XiLinx SDK FreeRTOS学习记录（一）——HelloWorld示例工程](https://www.zzy-blog.top/RTOS20231130/)与之前讲的[vivado UART串口学习记录](https://www.zzy-blog.top/vivado20231128/)，将其移植到RTOS中来。

## 大致思路
我们可以直接在HelloWorld示例工程上进行修改，但是我们不需要发送数据到队列这个任务了，因为发送是蓝牙发送的，我们只需要保留从队列接收数据的任务即可。然后对于UART、GIC这些的配置问题，我们可以直接放在一个任务中去完成，但是由于RTOS的任务会一直执行，我们只需要执行一次即可，因此我们可以在这个任务完成一次后就将其删掉，使用`vTaskDelete()`函数，其中的参数是任务的句柄，但是当任务要删除自己的时候直接使用`NULL`即可。

然后在之前的代码中，我们将UART收到的内容打印出来，而移植到RTOS中就不需要了，我们将数据存下来然后发送给队列，接收任务再从队列中取出，打印出数据。

## 注意事项
1. 我们可能会打印一个启动标志例如“Yuan Shen Qi Dong!”，但是注意这个操作应该在所有初始化设置完成后，否则会出现打印数据乱码的情况，乱码还有可能是因为波特率设置有问题，注意检查。

1. 在UART中断服务函数发送数据到队列时应该使用`xQueueSendFromISR()`函数而不是`xQueueSend()`.

1. 在实际测试中发现了这样的情况，首先是FIFO不会清空，就是说假如我们设定的最大接收字节是135，实际发送了136，这第136个字节仍然会进入FIFO，只是不会被UART接收，这就导致下次再发送数据时，上次发送的第136个字节会成为这次的第1个字节。如果蓝牙传进来的两帧数据出现了一些问题，第一个发了140帧第二个发了130帧，这样的话是不会造成影响的，但是如果第一次发了130帧第二次发了140帧，这样的话就会有问题了，因此还是需要引入差错控制。

1. 还有一个问题是，存放接收到的数据的数组每次都需要清空会很麻烦，但是新接收到的数据一定是会覆盖掉原来的数据的，因此我们想到将每次接收到的数据一并传过来，打印的时候只将本次接收到的数据打印出来即可，或者也可以传来一个结构体，当打印结构体时还有一些问题之后解决。